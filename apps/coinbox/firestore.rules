rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
             ('admin' in request.auth.token) && 
             request.auth.token.admin == true;
    }
    
    function isSupport() {
      return isAuthenticated() && 
             (('admin' in request.auth.token && request.auth.token.admin == true) ||
              ('support' in request.auth.token && request.auth.token.support == true));
    }
    
    function hasValidTimestamp() {
      return request.resource.data.createdAt == request.time;
    }
    
    // Public collections: allow read for everyone, write for no one
    match /publicData/{document=**} {
      allow read: if true;
      allow write: if false;
    }
    match /stats/{doc} {
      allow read: if true;
      allow write: if false;
    }
    // Public aggregated stats (for homepage)
    match /publicStats/{document=**} {
      allow read: if true;
      allow write: if false;
    }
    match /publicContent/{doc} {
      allow read: if true;
      allow write: if false;
    }
    match /testimonials/{doc} {
      allow read: if true;
      allow write: if false;
    }
    match /press/{doc} {
      allow read: if true;
      allow write: if false;
    }
    match /education/{doc} {
      allow read: if true;
      allow write: if false;
    }
    match /systemStatus/{doc} {
      allow read: if true;
      allow write: if false;
    }
    match /news/{doc} {
      allow read: if true;
      allow write: if false;
    }
    match /coins/{doc} {
      allow read: if true;
      allow write: if false;
    }

    // Users collection
    match /users/{userId} {
      // Users can read their own data, admins can read all
      allow read: if isOwner(userId) || isAdmin();
      
      // Users can create their own profile during signup
      allow create: if isOwner(userId) && hasValidTimestamp();
      
      // Users can update their own data (except role and membership status)
      allow update: if isOwner(userId) && 
                      !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'membershipStatus', 'membershipTier']);
      
      // Only admins can delete users
      allow delete: if isAdmin();
    }
    
    // User memberships
    match /user_memberships/{userId} {
      allow read: if isOwner(userId) || isSupport();
      allow write: if isAdmin();
    }
    
    // Trading tickets
    match /tickets/{ticketId} {
      // Users can read their own tickets and open tickets
      allow read: if isAuthenticated() && 
                    (resource.data.userId == request.auth.uid || 
                     resource.data.status == 'Open' ||
                     isSupport());
      
      // Users can create tickets for themselves
      allow create: if isAuthenticated() && 
                      request.resource.data.userId == request.auth.uid &&
                      hasValidTimestamp();
      
      // Users can update their own tickets (limited fields)
      allow update: if isAuthenticated() && 
                      resource.data.userId == request.auth.uid &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'updatedAt', 'description']);
      
      // Only admins can delete tickets
      allow delete: if isAdmin();
    }
    
    // Transactions
    match /transactions/{transactionId} {
      // Allow public read for anonymized transaction feed (homepage)
      // Full transaction details only for authenticated users
      allow read: if true;
      
      // Only system can create transactions (via server-side code)
      allow create: if false;
      
      // No updates or deletes allowed (immutable audit trail)
      allow update, delete: if false;
    }
    
    // Payments
    match /payments/{paymentId} {
      // Users can only read their own payments, support can read all
      allow read: if isAuthenticated() && 
                    (resource.data.userId == request.auth.uid || isSupport());
      
      // Only system can create/update payments (via webhooks)
      allow create, update: if false;
      
      // No deletes (audit trail)
      allow delete: if false;
    }
    
    // Disputes
    match /disputes/{disputeId} {
      // Participants and support can read
      allow read: if isAuthenticated() && 
                    (resource.data.initiatorId == request.auth.uid || 
                     resource.data.respondentId == request.auth.uid ||
                     isSupport());
      
      // Users can create disputes
      allow create: if isAuthenticated() && 
                      request.resource.data.initiatorId == request.auth.uid &&
                      hasValidTimestamp();
      
      // Participants can update (add evidence), admins can resolve
      allow update: if (isAuthenticated() && 
                       (resource.data.initiatorId == request.auth.uid || 
                        resource.data.respondentId == request.auth.uid)) ||
                       isAdmin();
      
      // Only admins can delete
      allow delete: if isAdmin();
    }
    
    // KYC documents
    match /kyc_documents/{documentId} {
      // Users can only read their own documents, support can read all
      allow read: if isAuthenticated() && 
                    (resource.data.userId == request.auth.uid || isSupport());
      
      // Users can create their own KYC documents
      allow create: if isAuthenticated() && 
                      request.resource.data.userId == request.auth.uid &&
                      hasValidTimestamp();
      
      // Users cannot update KYC docs once submitted, only admins can verify
      allow update: if isAdmin();
      
      // Only admins can delete
      allow delete: if isAdmin();
    }
    
    // Notifications
    match /notifications/{notificationId} {
      // Users can only read their own notifications
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Only system can create notifications
      allow create: if false;
      
      // Users can mark as read
      allow update: if isAuthenticated() && 
                      resource.data.userId == request.auth.uid &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt']);
      
      // Users can delete their own notifications
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Flagged Users (fraud detection)
    match /flagged_users/{userId} {
      // Only admins and support can read flagged user records
      allow read: if isSupport();
      
      // Only system and admins can create/update flagged user records
      allow create, update: if isAdmin();
      
      // Only admins can delete
      allow delete: if isAdmin();
    }
    
    // Rate limiting
    match /rateLimits/{limitId} {
      // No direct access - only server-side
      allow read, write: if false;
    }
    
    // Flagged accounts (security)
    match /flaggedAccounts/{userId} {
      // Only admins can read
      allow read: if isAdmin();
      
      // Only system can write
      allow write: if false;
    }
    
    // Audit logs (immutable)
    match /audit_logs/{logId} {
      // Only admins can read audit logs
      allow read: if isAdmin();
      
      // No direct writes (only via server)
      allow create, update, delete: if false;
    }
    
    // System configuration (admins only)
    match /system_config/{configId} {
      allow read: if isAdmin();
      allow write: if isAdmin();
    }
    
    // Commission records
    match /commissions/{commissionId} {
      // Users can read their own commissions
      allow read: if isAuthenticated() && 
                    (resource.data.referrerId == request.auth.uid || isSupport());
      
      // System can create/update commissions via server
      allow create, update: if false;
      
      // No deletes (audit trail)
      allow delete: if false;
    }
    
    // Commission payouts
    match /commission_payouts/{payoutId} {
      // Users can read their own payouts
      allow read: if isAuthenticated() && 
                    (resource.data.referrerId == request.auth.uid || isSupport());
      
      // System only
      allow create, update: if false;
      allow delete: if false;
    }
    
    // ==========================================
    // PHASE 2: WALLET + ESCROW SECURITY RULES
    // ==========================================
    
    // Wallets - CRITICAL: No client-side writes allowed
    match /wallets/{userId} {
      // Users can read their own wallet
      allow read: if isOwner(userId) || isAdmin();
      
      // NO client writes - only Cloud Functions can modify wallets
      allow create, update, delete: if false;
    }
    
    // Transactions - Immutable audit trail
    match /transactions/{txId} {
      // Users can read their own transactions
      allow read: if isAuthenticated() && 
                    (resource.data.userId == request.auth.uid || isAdmin());
      
      // NO client writes - only Cloud Functions
      allow create, update, delete: if false;
    }
    
    // P2P Offers
    match /p2p_offers/{offerId} {
      // Anyone can read active offers (marketplace)
      allow read: if true;
      
      // Users can create their own offers
      allow create: if isAuthenticated() && 
                      request.resource.data.userId == request.auth.uid &&
                      hasValidTimestamp();
      
      // Users can update their own offers (limited fields)
      allow update: if isAuthenticated() && 
                      resource.data.userId == request.auth.uid &&
                      !request.resource.data.diff(resource.data).affectedKeys()
                        .hasAny(['userId', 'completedOrders', 'totalOrders', 'rating', 'createdAt']);
      
      // Users can soft-delete their own offers (Cloud Function sets status='deleted')
      allow delete: if false;  // Use Cloud Function instead
    }
    
    // P2P Orders - Critical escrow protection
    match /p2p_orders/{orderId} {
      // Only participants and admins can read
      allow read: if isAuthenticated() && 
                    (resource.data.buyerId == request.auth.uid || 
                     resource.data.sellerId == request.auth.uid ||
                     isAdmin());
      
      // NO direct creation - must use Cloud Function for escrow lock
      allow create: if false;
      
      // NO direct updates - use Cloud Functions for state changes
      allow update: if false;
      
      // NO deletes - orders are immutable
      allow delete: if false;
    }
    
    // Chat Messages
    match /chat_messages/{messageId} {
      // Participants can read messages for their orders
      allow read: if isAuthenticated() && 
                    (get(/databases/$(database)/documents/p2p_orders/$(resource.data.orderId)).data.buyerId == request.auth.uid ||
                     get(/databases/$(database)/documents/p2p_orders/$(resource.data.orderId)).data.sellerId == request.auth.uid ||
                     isAdmin());
      
      // Users can create messages for their orders
      allow create: if isAuthenticated() && 
                      request.resource.data.senderId == request.auth.uid &&
                      hasValidTimestamp();
      
      // No updates or deletes
      allow update, delete: if false;
    }
    
    // Escrow Locks - System only
    match /escrow_locks/{lockId} {
      // Only admins can read escrow locks
      allow read: if isAdmin();
      
      // NO client writes - only Cloud Functions
      allow create, update, delete: if false;
    }
    
    // Fraud Logs - System only
    match /fraud_logs/{logId} {
      // Only admins can read fraud logs
      allow read: if isAdmin();
      
      // NO client writes
      allow create, update, delete: if false;
    }
    
    // User Risk Profiles - Read-only for users
    match /user_risk_profiles/{userId} {
      // Users can read their own risk profile, admins can read all
      allow read: if isOwner(userId) || isAdmin();
      
      // NO client writes - only Cloud Functions
      allow create, update, delete: if false;
    }
    
    // Paystack Webhooks - System only
    match /paystack_webhooks/{webhookId} {
      // Only admins can read
      allow read: if isAdmin();
      
      // NO client writes
      allow create, update, delete: if false;
    }
    
    // Rate Limits - System only
    match /rate_limits/{limitId} {
      allow read, write: if false;
    }
    
    // ============================================
    // P2P CRYPTO MARKETPLACE RULES
    // ============================================
    
    // P2P Crypto Listings
    match /p2p_crypto_listings/{listingId} {
      // Anyone authenticated can read active listings
      allow read: if isAuthenticated();
      
      // Only authenticated users can create listings
      allow create: if isAuthenticated() && 
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.status == 'active';
      
      // Only the creator or admin can update/delete
      allow update: if (isOwner(resource.data.userId) || isAdmin()) &&
                      // Can only update allowed fields
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['userId', 'createdAt']));
      
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }
    
    // P2P Crypto Transactions
    match /p2p_crypto_transactions/{transactionId} {
      // Only buyer, seller, or admin can read
      allow read: if isAuthenticated() && 
                    (resource.data.buyerId == request.auth.uid || 
                     resource.data.sellerId == request.auth.uid || 
                     isAdmin());
      
      // Only system (via API) or admin can create
      allow create: if isAuthenticated() &&
                      (request.resource.data.buyerId == request.auth.uid || 
                       request.resource.data.sellerId == request.auth.uid);
      
      // Only buyer, seller, or admin can update status
      allow update: if isAuthenticated() && 
                      (resource.data.buyerId == request.auth.uid || 
                       resource.data.sellerId == request.auth.uid || 
                       isAdmin()) &&
                      // Validate status transitions
                      (request.resource.data.status in ['pending_payment', 'payment_confirmed', 'crypto_released', 'completed', 'disputed', 'cancelled']);
      
      // Only admin can delete
      allow delete: if isAdmin();
    }
    
    // P2P Crypto User Stats
    match /p2p_crypto_stats/{userId} {
      // Users can read their own stats, admins can read all
      allow read: if isOwner(userId) || isAdmin();
      
      // Only the user or admin can create/update their stats
      allow create, update: if isOwner(userId) || isAdmin();
      
      // Only admin can delete
      allow delete: if isAdmin();
    }
    
    // P2P Crypto Escrow Records
    match /p2p_crypto_escrow/{escrowId} {
      // Only buyer, seller, or admin can read
      allow read: if isAuthenticated() && 
                    (resource.data.buyerId == request.auth.uid || 
                     resource.data.sellerId == request.auth.uid || 
                     isAdmin());
      
      // Only system (via API) or admin can write
      allow create, update: if isAdmin();
      
      // Only admin can delete
      allow delete: if isAdmin();
    }
    
    // P2P Crypto Fee Records
    match /p2p_crypto_fees/{feeId} {
      // Only admin can read fee records
      allow read: if isAdmin();
      
      // Only system (via API) or admin can write
      allow create, update: if isAdmin();
      
      // Only admin can delete
      allow delete: if isAdmin();
    }
    
    // P2P Ratings
    match /p2p_ratings/{ratingId} {
      // Anyone can read ratings (public reputation)
      allow read: if true;
      
      // Only authenticated users who completed the trade can rate
      allow create: if isAuthenticated() && 
                      request.resource.data.raterId == request.auth.uid &&
                      request.resource.data.rating >= 1 && 
                      request.resource.data.rating <= 5 &&
                      request.resource.data.createdAt == request.time;
      
      // Cannot update or delete ratings (immutable)
      allow update, delete: if false;
    }
    
    // P2P Reputation
    match /p2p_reputation/{userId} {
      // Anyone can read reputation (public)
      allow read: if true;
      
      // Only system functions can write reputation (server-side calculation)
      allow create, update: if false;
      
      // Only admin can delete
      allow delete: if isAdmin();
    }
    
    // P2P Notifications
    match /p2p_notifications/{notificationId} {
      // Users can only read their own notifications
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Users can mark their own notifications as read
      allow update: if isAuthenticated() && 
                      resource.data.userId == request.auth.uid &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt']);
      
      // Only system can create notifications
      allow create: if false;
      
      // Users can delete their own notifications
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Crypto Wallets (Hybrid Model with Luno)
    match /cryptoWallets/{userId} {
      // Users can read their own wallet
      allow read: if isOwner(userId) || isAdmin();
      
      // Only system can create/update wallets (prevent tampering)
      allow create, update: if false;
      
      // Only admin can delete
      allow delete: if isAdmin();
    }
    
    // Crypto Orders (Order Book)
    match /cryptoOrders/{orderId} {
      // Users can read PENDING orders (public order book) or their own orders
      allow read: if isAuthenticated() && 
                    (resource.data.status == 'PENDING' || 
                     resource.data.userId == request.auth.uid || 
                     isAdmin());
      
      // Users can create their own orders with validation
      allow create: if isAuthenticated() && 
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.amount > 0 &&
                      request.resource.data.price > 0 &&
                      request.resource.data.status == 'PENDING' &&
                      request.resource.data.type in ['BUY', 'SELL'] &&
                      request.resource.data.asset in ['BTC', 'ETH', 'USDT', 'SOL', 'XRP'];
      
      // Only owner can cancel their orders, system updates via API
      allow update: if isAuthenticated() && 
                      (resource.data.userId == request.auth.uid || isAdmin()) &&
                      // Users can only cancel, system handles matching
                      (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'updatedAt']) &&
                       request.resource.data.status in ['CANCELLED', 'COMPLETED', 'PARTIAL']);
      
      // Only admin can delete
      allow delete: if isAdmin();
    }
    
    // Crypto Balances
    match /cryptoBalances/{userId} {
      // Users can read their own balances
      allow read: if isOwner(userId) || isAdmin();
      
      // Only system can update balances (prevent tampering)
      allow create, update: if false;
      
      // Only admin can delete
      allow delete: if isAdmin();
    }
    
    // Crypto Transactions
    match /cryptoTransactions/{transactionId} {
      // Users can read their own transactions, admins can read all
      allow read: if isAuthenticated() && 
                    (resource.data.userId == request.auth.uid || isAdmin());
      
      // Only system can create transactions (prevent fake transactions)
      allow create, update, delete: if false;
    }
    
    // Savings Jar
    match /savingsJar/{userId} {
      // Users can read their own savings jar
      allow read: if isAuthenticated() && 
                    (userId == request.auth.uid || isAdmin());
      
      // Only system can create/update (via API)
      allow create, update, delete: if false;
    }
    
    // Savings Jar Transactions
    match /savingsJarTransactions/{transactionId} {
      // Users can read their own transactions
      allow read: if isAuthenticated() && 
                    (resource.data.userId == request.auth.uid || isAdmin());
      
      // Only system can create
      allow create, update, delete: if false;
    }
    
    // Operations Log (idempotency)
    match /operations_log/{operationId} {
      // Users can read their own operations
      allow read: if isAuthenticated() && 
                    (resource.data.userId == request.auth.uid || isAdmin());
      
      // Only system can write
      allow create, update, delete: if false;
    }
    
    // Catch-all: deny by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
